# 手写题

## 手写一个深拷贝

```js
function deepClone(obj){
    if(typeof obj !== 'object' || typeof obj === null) return obj;

    const result = obj instanceof Array? []: {}

    for(let key in obj){

        result[key] = deepClone(obj[key])
        //浅拷贝 resutl[key] = obj[key]
    } 
    return result;
}

const obj = {a: 1, b: {c:3}, d: 5}
const objClone = deepClone(obj)
obj.a = 123
console.log(obj) //{a: 123, b: {…}, d: 5}
console.log(objClone) //{a: 1, b: {…}, d: 5}
```

## 手写防抖和节流函数

### 防抖


#### 停止触发事件n毫秒后执行回调函数

触发事件后函数不会立即执行，而是在停止事件触发后 n 毫秒后执行，如果在 n 毫秒内又触发了事件，则会重新计时

```js
function debounce(fn, delay){
    let timer = null;

    return function(){

        if(timer) clearTimeout(timer)

        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}
```

#### 触发事件后立即执行回调函数，但是触发后n毫秒内不会再执行回调函数，如果 n 毫秒内触发了事件，也会重新计时。

```js
function debounce(fn, delay){
    let timer;

    return function(){

        let isImmediate = !timer

        if(timer) clearTimeout(timer)
        
        timer = setTimeout(() => {
            timer = null
        }, delay)

        if(isImmediate) {
            fn.apply(this, arguments)
            
        }
    }
}
```
举个例子来对比一下两个版本的区别：

```js
document.body.onclick= debounce(function () { console.log('hello') },1000)

```
如上代码中，我们给body添加了一个点击事件监听器。

如果是版本1的防抖函数，当我点击body时，控制台不会立即打印hello,要等 1000ms 后才会打印。在这 1000s 内如果还点击了 body，那么就会重新计时。即最后一次点击 body 过1000ms后控制台才会打印hello

如果是版本2的防抖函数，当我首次点击body时，控制台会立马打印 hello，但是在此之后的 1000ms 内点击 body ，控制台不会有任何反应。在这 1000s 内如果还点击了 body，那么就会重新计时。必须等计时结束后再点击body，控制台才会再次打印 hello。

### 节流

#### 使用定时器

```js
function throttle(fn, delay){
    let timer;

    return function(){

        if(timer) return

        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null;
            clearTimeout(timer)
        }, delay)
    }
}
```
#### 计算当前时间与上次执行函数时间的间隔

```js
function throttle(fn, dalay){
    let previous = 0;

    return function(){

        let now = Date.now()

        if(now - previous > delay){
            fn.apply(this, arguments)
            previous = now
        }
    }
}
```
## 手写快速排序

```js
function quickSort(arr: number[], startIndex = 0): number[] { 
    if(arr.length <= 1) return arr
    const left: number[] = [], right: number[] = [];
    const startNum = arr.splice(startIndex, 1)[0]
    for(let i = 0; i < arr.length; i++){
        if(arr[i] < startNum){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return [...quickSort(left), startNum, ...quickSort(right)]
}
```

## 输入为两个一维数组，将这两个数组合并，去重，不要求排序，返回一维数组

```js
function dealArr(arr: any[], arr2: any[]): any[] {
    Array.from(new Set([...arr.flat(), ...arr2.flat()]))
}
```

## 编写函数convert(money) ，传入金额，将金额转换为千分位表示法。ex:-87654.3 => -87,654.3

```js
function convert(money: number): string {
    const result: string[] = []
    const tail: string = ''
    const negativeFlag: string = ""
    const arr: string[] = [...string(money)]
}
```