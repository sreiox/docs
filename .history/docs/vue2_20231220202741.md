# vue2

## 0. 原理解读

### defineProperty/get/set

```js
//Object.defineProperty(obj, 'foo', {configurable: true, writable: true, enumable: true})
function convert(obj){
    Object.keys(obj).forEach(key => {
        let initalValue = obj[key];
        Object.defineProperty(obj, key, {
            get () {
                return initalValue
            }
            set (newValue) {
                initalValue = newValue
            }
        })
    })
}
```

### 依赖追踪（订阅者模式）

```js
window.Dep = Class Dep {
    constructor(){
        this.subscribers = new Set()
    }

    depend(){
        // 依赖收集
        if(activeUpdate){
            this.subscribers.add(activeUpdate)
        }
    }

    notify(){
        // 通知订阅者执行
        this.subscribers.forEach(sub => sub())
    }
}

let activeUpdate

function autorun(update){
    // activeUpdate本质记录正在执行
    function wrappedUpdate{
        activeUpdate = wrappedUpdate
        update()
        activeUpdate = null
    }

    wrappedUpdate()
}

const dep = new Dep()
autorun(() => {
    dep.depend()
})
```

```js
let state = { count: 0 }
// 首先对象通过defineproperty开启监控
obeserve(state)

autorun(() => {
    console.log(state.count)
})

state.count++
```

## 说一下vue2的生命周期？

1. 创建：
    - beforecreate: 实例创建前, 此阶段的data、methods、computed、watch的数据和方法不能被访问
    - created: 实例创建完成后, 此阶段完成数据监听，可以使用数据、更改数据。无法与Dom进行交互，想要的话可以通过nextTick来访问。
2. 挂载
    - beforeMount: 页面渲染前, 此阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。
    - mounted: 页面渲染完成后, 此阶段真实Dom渲染完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。
3. 更新
    - beforeUpdate: 响应式数据更新前, 此阶段更改数据，不会造成页面重新渲染。
    - updated: 响应式数据更新完成后, 避免在此阶段更改数据，因为这可能会导致无限循环的更新。
4. 销毁
    - beforeDestroy: 实例销毁前, 我们可以在这时进行善后收尾工作，比如清除定时器、解除绑定事件
    - destroyed: 实例销毁完成后
5. 缓存
    - activited: `keep-alive`专属，组件被激活时调用
    - deactivited: keep-alive专属，组件被销毁时调用

### 异步请求放在created还是mounted

首先明确的一个前提是：请求是异步的。

在Created生命周期里Data才生成，而请求返回的数据需要挂载在data上，所以Created里是可以初始化请求的，但是 Created 的这时候DOM还没有初始化；

Mounted生命周期里DOM才初始化渲染完成

如果我们的请求不需要获取/借助/依赖/改变DOM，这时请求可以放在Created

反之则可以放在Mounted里

### 父子组件生命周期执行顺序

组件渲染的顺序是先父后子，渲染完成的顺序是先子后父

组件更新的顺序是先父后子，更新完成的顺序是先子后父

组件销毁的顺序是先父后子，销毁完成的顺序是先子后父

## 1. 什么是Vue以及Vue的特点

vue是一套用于构建用户界面的渐进式（自底向上逐层应用）js框架

1. 组件化开发
2. 无需操作DOM
3. 使用虚拟DOM和diff算法复用DOM节点

## 2. SPA及其优缺点

SPA:signal page application，单一页面应用。

一旦页面加载完成，不会因为用户在浏览器上的操作而进行`跳转`、`刷新`，取而代之的是利用`路由机制实现的HTML内容的变换`、UI和用户的交互，`避免`页面的`重新加载`。

数据需要通过ajax请求获取。

优点：

1. 避免不必要的跳转和重复渲染，提高了用户的体验，减轻了服务器的压力。
2. `前后端分离`，使架构更加清晰。

缺点：

1. 初次加载耗时长（可以通过`按需加载`来避免）。
2. 浏览器的前进后退不可以使用，要自己建立堆栈来进行页面切换。
3. SEO难度大。因为就一个页面。

## 2. v-if和v-show的区别

v-if是真正的条件渲染，`不停地的进行销毁和重建`，但若初始条件为假时，就什么也不做。

v-show无论初始渲染条件是否为真，`都进行渲染`，只是使用“display”属性来控制是否在页面上显示

::: tip
Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.
:::


## 3. [class 和 style如何动态绑定](https://vuejs.org/guide/essentials/class-and-style.html)

都可以通过对象和数组来绑定。

## 4. 怎样理解Vue的单项数据流

父级的prop的更新会向下流动到子级的prop里，但是反过来不可以， 若想反过来，只能通过`$emit`派发一个自定义事件，父组件接到后由父组件修改

## 5. v-for中key的作用？

key代表的是唯一，作用是更高效的更新虚拟dom，diff算法时便于区分新旧虚拟dom，新旧虚拟dom的key相同时不会重新渲染，提高性能

为何不推荐index作为key值：当以数组下标index作为key值时，当其中一个元素发生了变化(增删改查)，就有能导致所有的元素的key值发生改变，导致更新dom时浪费性能

## 说一下组件通信有哪些方式？

1. 父传子
    - 自定义属性 + props：在父组件中，给子组件绑定一个自定义属性，在子组件中，通过props进行接收
    - $parent：直接访问父组件实例的属性和方法
    - $attrs：在父组件中，给子组件绑定一个自定义属性，在子组件中，通过$attrs进行接收【与props不能共存】
    - 插槽
2. 子传父
    - $emit + 自定义事件：在父组件中，给子组件绑定一个自定义事件，绑定事件的值为接收参数的函数，在子组件中，通过$emit发送数据
    - $refs：直接访问子组件实例的属性和方法
    - $children：直接访问子组件实例的属性和方法【返回数组，必须遍历赋值后才能渲染】
3. 祖传孙/孙传祖
    - provide函数传，inject数组收
4. 兄弟间
    - [$bus 全局事件总线：给vue原型添加一个vue实例，用this.$bus.$emit发送，用this.$bus.$on接收](https://stackoverflow.com/questions/68549222/emit-data-with-eventbus)
5. vuex
6. 路由传参
    - params传参（地址栏不显示参数）
    - query传参（地址栏显示参数

## watch和computed的区别

computed计算属性：

- 如果一个数据需要经过复杂计算就用computed
- 支持缓存，只有依赖数据发生改变时，才会重新进行计算
- 不支持异步，当计算属性内有异步操作时，无法监听到数据的变化。原因：定义的函数接收return的结果，return属于同步执行的，是没办法拿到异步请求结果的
- 计算属性只能取不能存，即不能对计算属性直接赋值。如需要存，要给计算属性手动添加setter

watch监听器

- 如果一个数据需要被监听并且对数据做一些异步操作就用watch
- 不支持缓存，数据变化会直接触发相应的操作

## 说一下为什么data是一个函数？

data必须是函数，是为了保证不同组件的`独立性`和`可复用性`，防止不同组件实例间data的引用关系，避免变量污染

## 说一下对keep-alive的理解？

缓存组件，减少请求次数, 需要缓存用户数据类似表单

根据条件缓存页面的方式：

- :include="['组件name']" 指定想要缓存的组件,其他组件不缓存

- :exclude="['组件name']" 指定不想要缓存的组件,其他组件缓存

- 利用路由的元属性meta，配合v-if动态判断



两个钩子函数：

- activated()：进入这个缓存组件时触发

- deactivated()：离开这个缓存组件时触发

## 说一下对MVVM的理解？

M是model，指的是数据层，即data，V是view，指的是视图层，即template，VM是viewModel，指的是视图模型，即vue实例，是连接view和model的桥梁。数据和视图不能直接通信，必须经过VM实现通信。

## 说一下vue2的响应式原理？

vue2采用`数据代理+数据劫持+发布订阅`模式的方法。

在初始化vue实例时，会把data对象和data对象的属性都添加到`vm对象`中，通过`object.defineProperty()`进行数据代理，用vm对象的属性来`代理data`对象的属性，

并在`Observer`类中`递归遍历data`对象，对data对象中的每个属性都进行`数据劫持`，都指定一个`getter、setter`。

例外的，对于数组，不能通过object.defineProperty()进行数据代理，因为监听的数组下标变化时会出现数据错乱问题，所以数组是调用`数组重写的原生方法`来实现响应式。



当通过vm对象修改data对象中的属性时，会触发data属性的`setter`方法，然后触发它`Dep实例的notify`方法进行依赖分发，通知所有依赖的`Watcher`实例执行内部回调函数。

最后会触发`renderWatcher`回调，会重新执行`render函数`，重新`对比新旧虚拟DOM`，`重新渲染`页面。

【Watcher回调是异步任务，它的执行会遵循事件循环机制，且重复的Watcher回调不会放到任务队列中，所以多次重复数据更新时，只会重新渲染一次页面】。

当通过vm对象读取data对象中的属性时，会触发data属性的getter方法，然后触发它Dep实例的depend方法进行依赖收集。



当data对象中数组元素发生变化时，会调用数组重写的原生方法，然后触发它Dep实例的notify方法进行依赖分发，通知所有依赖的Watcher实例执行内部回调函数。

最后会触发renderWatcher回调，会重新执行render函数，重新对比新旧虚拟DOM，重新渲染页面。

当读取data对象中数组元素时，会触发数组的getter方法，然后触发它Dep实例的depend方法进行依赖收集。



# vuex

## 说一下对vuex的理解？

五种状态：

- state: 存储公共数据 this.$store.state
- mutations：同步操作，改变store的数据 this.$store.commit()
- actions: 异步操作，让mutations中的方法能在异步操作中起作用 this.$store.dispatch()
- getters: 计算属性 this.$store.getters
- modules: 子模块

使用场景：

用户信息、菜单信息、购物车信息

解决vuex页面刷新数据丢失问题的方式：

- 将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）
- 在页面刷新的时候再次请求远程数据，使之动态更新vuex数据


