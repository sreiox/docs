# 手写题

## 手写一个深拷贝

```js
function deepClone(obj){
    if(typeof obj !== 'object' || typeof obj === null) return obj;

    const result = obj instanceof Array? []: {}

    for(let key in obj){

        result[key] = deepClone(obj[key])
        //浅拷贝 resutl[key] = obj[key]
    } 
    return result;
}

const obj = {a: 1, b: {c:3}, d: 5}
const objClone = deepClone(obj)
obj.a = 123
console.log(obj) //{a: 123, b: {…}, d: 5}
console.log(objClone) //{a: 1, b: {…}, d: 5}
```

## 手写防抖和节流函数

### 防抖


#### 停止触发事件n毫秒后执行回调函数

触发事件后函数不会立即执行，而是在停止事件触发后 n 毫秒后执行，如果在 n 毫秒内又触发了事件，则会重新计时

```js
function debounce(fn, delay){
    let timer = null;

    return function(){

        if(timer) clearTimeout(timer)

        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}
```

#### 触发事件后立即执行回调函数，但是触发后n毫秒内不会再执行回调函数，如果 n 毫秒内触发了事件，也会重新计时。

```js
function debounce(fn, delay){
    let timer;

    return function(){

        let isImmediate = !timer

        if(timer) clearTimeout(timer)
        
        timer = setTimeout(() => {
            timer = null
        }, delay)

        if(isImmediate) {
            fn.apply(this, arguments)
            
        }
    }
}
```
举个例子来对比一下两个版本的区别：

```js
document.body.onclick= debounce(function () { console.log('hello') },1000)

```
如上代码中，我们给body添加了一个点击事件监听器。

如果是版本1的防抖函数，当我点击body时，控制台不会立即打印hello,要等 1000ms 后才会打印。在这 1000s 内如果还点击了 body，那么就会重新计时。即最后一次点击 body 过1000ms后控制台才会打印hello

如果是版本2的防抖函数，当我首次点击body时，控制台会立马打印 hello，但是在此之后的 1000ms 内点击 body ，控制台不会有任何反应。在这 1000s 内如果还点击了 body，那么就会重新计时。必须等计时结束后再点击body，控制台才会再次打印 hello。

### 节流

#### 使用定时器

```js
function throttle(fn, delay){
    let timer;

    return function(){

        if(timer) return

        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null;
            clearTimeout(timer)
        }, delay)
    }
}
```
#### 计算当前时间与上次执行函数时间的间隔

```js
function throttle(fn, dalay){
    let previous = 0;

    return function(){

        let now = Date.now()

        if(now - previous > delay){
            fn.apply(this, arguments)
            previous = now
        }
    }
}
```
## 手写快速排序

```js
function quickSort(arr: number[], startIndex = 0): number[] { 
    if(arr.length <= 1) return arr
    const left: number[] = [], right: number[] = [];
    const startNum = arr.splice(startIndex, 1)[0]
    for(let i = 0; i < arr.length; i++){
        if(arr[i] < startNum){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return [...quickSort(left), startNum, ...quickSort(right)]
}
```

## 输入为两个一维数组，将这两个数组合并，去重，不要求排序，返回一维数组

```js
function dealArr(arr: any[], arr2: any[]): any[] {
    Array.from(new Set([...arr.flat(), ...arr2.flat()]))
}
```

## 编写函数convert(money) ，传入金额，将金额转换为千分位表示法。ex:-87654.3 => -87,654.3

```js
function convert(money: number): string {
    let result: string[] = []
    let tail: string = ''
    let negativeFlag: string = ""
    let arr: string[] = [...String(money)]

    if(arr[0] === '-') {
        negativeFlag = '-'
        arr.shift(0, 1)
    }

    let dotIndex: number = arr.indexOf('.')

    if(dotIndex !== -1){
        tail = arr.splice(dotIndex, arr.length - dotIndex).join("")
    }

    let reverseArr: string[] = arr.reverse()
    for(let i = 0; i < reverseArr.length; i++){
        if((i+1)%3 === 0 && i < reverseArr.length){
            result[i] = ',' + reverseArr[i]
        }else{
            result[i] = reverseArr[i]
        }
    }
    return negativeFlag + result.reverse().join("") + tail
}
```

## 手写Promise

我们先来回顾下最简单的 Promise 使用方式：

```js
const p1 = new Promise((resolve, reject) => {
  console.log('create a promise');
  resolve('成功了');
})

console.log("after new promise");

const p2 = p1.then(data => {
  console.log(data)
  throw new Error('失败了')
})

const p3 = p2.then(data => {
  console.log('success', data)
}, err => {
  console.log('faild', err)
})
```

控制台输出:

```js
"create a promise"
"after new promise"
"成功了"
"faild Error: 失败了"
```

- 首先我们在调用 Promise 时，会返回一个 `Promise 对象`。
- 构建 Promise 对象时，需要传入一个 `executor` 函数，Promise 的主要业务流程都在 executor 函数中执行。
- 如果运行在 excutor 函数中的业务执行`成功`了，会调用 `resolve` 函数；如果执行`失败`了，则调用 `reject `函数。
- `Promise 的状态不可逆`，同时调用 `resolve` 函数和 `reject` 函数，默认会采取第一次调用的结果。

以上简单介绍了 Promise 的一些主要的使用方法，结合 `Promise/A+` 规范，我们可以分析出 Promise 的基本特征：

> 1. `promise` 有三个状态：`pending`，`fulfilled`，or `rejected`；「规范 Promise/A+ 2.1」
> 2. `new promise`时， 需要传递一个`executor()`执行器，执行器`立即执行`；
> 3. `executor`接受两个参数，分别是`resolve`和`reject`；
> 4. `promise` 的默认状态是 `pending`；
> 5. `promise` 有一个`value`保存成功状态的值，可以是`undefined/thenable/promise`；「规范 Promise/A+ 1.3」
> 6. `promise` 有一个`reason`保存失败状态的值
> 7. `promise` 只能从`pending`到`rejected`, 或者从`pending`到`fulfilled`，状态`一旦确认`，就`不会再改变`；
> 8. `promise` 必须有一个`then`方法，then 接收两个参数，分别是 `promise` 成功的回调 `onFulfilled`, 和 `promise` 失败的回调 `onRejected`；「规范 Promise/A+ 2.2」
> 9. 如果调用 `then` 时，`promise` 已经`成功`，则执行`onFulfilled`，参数是`promise`的`value`
> 10. 如果调用 `then `时，`promise` 已经`失败`，那么执行`onRejected`, 参数是`promise`的`reason`；
> 11. 如果 `then` 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 `then` 的失败的回调`onRejected`；

按照上面的特征，我们试着勾勒下 Promise 的形状：

```js
// 三个状态：PENDING、FULFILLED、REJECTED
const PROMISE_STATUS_PENDING = 'pending'
const PROMISE_STATUS_FULFILLED = 'fulfilled'
const PROMISE_STATUS_REJECTED = 'rejected'

class MyPromise {
    constructor(exector){
        // 默认状态为 PENDING
        this.status = PROMISE_STATUS_PENDING
        // 存放成功状态的值，默认为 undefined
        this.value = undefined
        // 存放失败状态的值，默认为 undefined
        this.reason = undefined
        this.onFulfilledFns = []
        this.onRejectedFns = []

        // 调用此方法就是成功
        let resolve
    }
}
```