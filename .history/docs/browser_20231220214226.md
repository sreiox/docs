# browser

## 1. 跨域问题

由于浏览器`同源策略`（浏览器安全功能，它会阻止一个域与另一个域的内容进行交互，能`有效防止XSS、CSRF攻击`）的限制，非同源的请求会被限制。

解决跨域问题的方法：

- 配置nginx反向代理
    跨域解决：location配置中，在响应头上添加允许访问的请求源 Access-Control-Allow-Origin:*
- 使用jsonp方式（script方式）
    利用srcipt标签的src属性来实现，前端声明好一个函数，后端返回执行函数，执行函数参数中携带所需的数据。
    可以使用jquery的ajax快速实现Jsonp。 
    使用jsonp只能解决get请求的跨域，因为script标签中的src请求就是get请求。
- 使用图片
- 设置CORS（跨域资源共享）
    在配置类中，添加一个CORS的过滤器，在响应头上添加允许访问的请求源 addAllowedOrigin("*")
- 利用iframe实现
- WebSocket

## 2. 浏览器的存储有哪些及它们间的区别

- cookie
- session storage
- local storage
- indexedDB:用于客户端存储大量的结构化数据（文件/二进制大型对象（blobs））。该API使用索引实现对数据的高性能搜索。
- cache storage：用于对Cache对象的存储。

## 3. 说说浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起`DNS请求`，得到对应的`IP地址`（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行`TCP三次握手`与服务器建立连接，连接建立后，浏览器会代表用户`发送一个初始的GET请求`，通常是请求一个`HTML文件`。服务器收到对应请求后 ，会根据`相关的响应头和HTML内容进行回复`。

一旦浏览器拿到了数据，就会开始`解析信息`，这个过程中，浏览器会根据`HTML文件去构建DOM树`，当遇到一些`阻塞资源`时（如同步加载的script标签）会去`加载阻塞资源而停止当前DOM树构建`（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的`预加载扫描器会去请求高优先级的资源（如css、js、字体）`，预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理`CSS生成CSSDOM树`，将CSS规则转换为可以理解和使用的`样式映射`，这个过程非常快（通常小于一次DNS查询所需时间）。有了`DOM树和CSSDOM`树，浏览器会将其组合生成一个`Render树`，`计算样式或渲染树会从DOM的根节点开始构建`，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始`布局`，该过程（依旧是从根节点开始）会确定所有节点的`宽高和位置`，最后通过渲染器将其在页面上`绘制`。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

![tupian](./assets/img/16.webp)

## 4. 说下线程和进程

`进程`：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。
`线程`：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。
`与进程不同的是`同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

## 5. 说下堆和栈

- 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
操作方式类似于数据结构中的栈。
- 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

## 6. http和https的区别

`HTTP（Hypertext Transfer Protocol`）和`HTTPS（Hypertext Transfer Protocol Secure）`是用于在`客户端和服务器之间传输数据的协议`。它们之间的主要区别在于`安全性和数据传输方式`：

- `安全性`：`HTTP是明文`传输协议，数据在传输过程中不加密，因此容易被恶意攻击者截取和篡改。而`HTTPS通过使用SSL`（Secure Sockets Layer）或`TLS`（Transport Layer Security）协议`对数据进行加密和身份验证`，确保数据在传输过程中的安全性。
- `数据传输方式`：`HTTP`使用的默认端口是`80`，而`HTTPS`使用的默认端口是`443`。`HTTP`的数据传输是`明文`的，而`HTTPS`的数据传输是`加密`的
- `证书`：为了使用`HTTPS`，服务器需要获得一个`数字证书`，该证书由权威机构颁发，用于验证服务器的身份和加密通信。而HTTP不需要使用证书。 总结来说，`HTTPS比HTTP更安全，因为它通过加密数据传输来保护用户的隐私和安全。在处理敏感信息（例如登录凭证、支付信息等）时，建议使用HTTPS来确保数据的安全传输。`

## 7. get和post的区别

get和post是HTTP协议中常用的两种请求方法，它们之间的主要区别如下：

1. `数据传输方式`： 
    - GET：通过`URL参数传递数据`，数据会附加在URL的末尾，以键值对的形式出现，例如：`example.com?name=John&age=25 `,GET请求通常`用于获取数据`，对`服务器的数据不会产生影响`。
    - POST: 通过`请求体传递数据`，数据不会附加在URL上，而是作为请求的一部分发送。POST请求通常`用于提交数据`，对`服务器的数据进行修改添加`。
2. `数据传输安全`
    - GET：数据以`明文形式出现在URL`上，因此在传输过程中`不够安全`。`适用于非敏感数据`。
    - POST：数据通过`请求体传输`，不会直接暴露在URL上，相对`更安全`。`适用于敏感数据`。
3. `数据长度限制`
    - `GET`：由于数据附加在URL上，`URL的长度受限制`，不适合传输大量数据。 
    - `POST`：由于数据在请求体中传输，`没有URL长度限制`，适合传输大量数据。
4. `缓存`
    - `GET：请求会被浏览器缓存`，可以通过浏览器的后`退按钮重新加载页面`。
    - `POST：请求不会被浏览器缓存`，重新加载页面时会重新发送请求。
5. `安全性`
    - GET：由于`数据暴露在URL`上，`容易被恶意攻击者截取和篡改`。
    - POST：相对于GET请求，POST请求的数据传输更加安全，因为数据不会直接暴露在URL上。

综上所述，`GET适合用于获取数据，POST适合用于提交数据`，根据具体的需求和数据的安全性要求选择合适的请求方法。

## 8. css加载会造成阻塞吗

CSS加载会造成浏览器的渲染阻塞。这是因为:

1. 浏览器在解析HTML文档时,会遇到link标签加载外部CSS文件,此时浏览器会暂停HTML解析,直到CSS文件加载完成。
2. 浏览器需要构建DOM树和CSSOM,并将两者合并成渲染树,才能开始页面渲染。如果CSS文件没有加载完成,浏览器无法构建渲染树,因此无法渲染页面。
3. CSS的加载和解析是同步的,浏览器需要等待CSS文件完全加载和解析完成后才会继续渲染页面。 

以上三个原因会造成CSS加载对浏览器的渲染产生阻塞效应。

为了避免这种阻塞,我们可以采取以下措施:












