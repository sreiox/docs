# promise

promise如何工作，首先了解`eventloop`执行顺序：
- 一开始整个脚本作为一个宏任务执行
- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务完成，检查微任务列表，有则依次执行，知道全部执行完成
- 执行浏览器ui线程得渲染工作
- 检查是否有`web work`任务，有则执行
- 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

**微任务**包括：`MutationObserver`、`Promise.then()`或`catch()`、`Promise为基础开发的其它技术`，比如`fetch API`、`V8`的垃圾回收过程、`Node独有的process.nextTick`。  

**宏任务**包括：`script` 、`setTimeout`、`setInterval` 、`setImmediate` 、`I/O` 、`UI rendering`。  

>注意⚠️：在所有任务开始的时候，由于宏任务中包括了`script`，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如`setTimeout`)将被放到下一轮宏任务中来执行。  

### 1. promise几道基础题

#### 1.1 题目一
```javascript
<script>
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
</script>
```

过程分析：  
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 然后执行同步代码`1`，此时`promise1`没有被`resolve`或者`reject`，因此状态还是`pending`  

结果：  
```javascript
'promise1'
'1' Promise{<pending>}
```
#### 1.2 题目二
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
</script>
```
过程分析：  
- 从上至下，先遇到`new Promise`，执行其中的同步代码`1`
- 再遇到`resolve('success')`， 将`promise`的状态改为了`resolved`并且将值保存下来  
- 继续执行同步代码`2`
- 跳出`promise`，往下执行，碰到`promise.then`这个微任务，将其加入微任务队列
- 执行同步代码`4`
- 本轮宏任务全部执行完毕，检查微任务队列，发现`promise.then`这个微任务且状态为`resolved`，执行它。

结果：  
```javascript
1 2 4 3
```
#### 1.3 题目三
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
</script>
```
过程分析：  
- 和题目二相似，只不过在`promise`中并没有`resolve`或者`reject`
- 因此`promise.then`并不会执行，它只有在被改变了状态之后才会执行。

结果：  
```javascript
1 2 4 
```
#### 1.4 题目四
```javascript
<script>
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);

</script>
```
过程分析：  
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 碰到`resolve`函数, 将`promise1`的状态改变为`resolved`, 并将结果保存下来
- 碰到`promise1.then`这个微任务，将它放入微任务队列
- `promise2`是一个新的状态为`pending`的`Promise`
- 执行同步代码`1`， 同时打印出`promise1`的状态是`resolved`
- 执行同步代码`2`，同时打印出`promise2`的状态是`pending`
- 宏任务执行完毕，查找微任务队列，发现`promise1.then`这个微任务且状态为`resolved`，执行它。
结果：  
```md
'promise1'
'1' Promise{<resolved>: 'resolve1'}
'2' Promise{<pending>}
'resolve1' 
```
#### 1.5 题目五
```javascript
<script>
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')

</script>
```
这道题里最先执行的是'`start`'吗 🤔️ ？

请仔细看看哦，`fn`函数它是直接返回了一个`new Promise`的，而且`fn`函数的调用是在`start`之前，所以它里面的内容应该会先执行。
结果：  
```md
1
'start'
'success'
```
### 2. Promise结合setTimeout  
   
#### 2.1 题目一
```javascript
<script>
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')

</script>
```
过程分析：  
- 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出`start`和`end`。
- `setTimout`作为一个宏任务被放入宏任务队列(下一个)
- `Promise.then`作为一个微任务被放入微任务队列
- 本次宏任务执行完，检查微任务，发现`Promise.then`，执行它
- 接下来进入下一个宏任务，发现`setTimeout`，执行。

结果：  
```javascript
'start'
'end'
'resolve'
'time'
```
#### 2.2 题目二
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);
</script>
```
过程分析：
和题目`1.2`很像，不过在`resolve`的外层加了一层`setTimeout`定时器。
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`1`
- 然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行
- 执行同步代码`2`
- 跳出`promise`函数，遇到`promise.then`，但其状态还是为`pending`，这里理解为先不执行
- 执行同步代码`4`
- 一轮循环过后，进入第二次宏任务，发现延迟队列中有`setTimeout`定时器，执行它
- 首先执行`timerStart`，然后遇到了`resolve`，将promise的状态改为`resolved`且保存结果并将之前的`promise.then`推入微任务队列
- 继续执行同步代码`timerEnd`
- 宏任务全部执行完毕，查找微任务队列，发现p`romise.then`这个微任务，执行它。

结果：  
```javascript
1
2
4
"timerStart"
"timerEnd"
"success"
```
#### 2.3 题目三
题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么  
①
```javascript
<script>
setTimeout(() => {
  console.log('timer1');
  setTimeout(() => {
    console.log('timer3')
  }, 0)
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')

</script>
```
②
```javascript
setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')

</script>
```
过程分析：
这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。  
一个是为定时器`timer3`，一个是为`Promise.then`  
但是如果是定时器`timer3`的话，它会在`timer2`后执行，而`Promise.then`却是在`timer2`之前执行。  
你可以这样理解，`Promise.then`是微任务，它会被加入到本轮中的微任务列表，而定时器`timer3`是宏任务，它会被加入到下一轮的宏任务中。  
理解完这两个案例，可以来看看下面一道比较难的题目了。

结果： ① 
```javascript
'start'
'timer1'
'timer2'
'timer3'
```
②
```javascript
'start'
'timer1'
'promise'
'timer2'
```
#### 2.4 题目四
```javascript
<script>
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');

</script>
```
这道题稍微的难一些，在`promise`中执行定时器，又在定时器中执行`promise`；

并且要注意的是，这里的`Promise`是直接`resolve`的，而之前的`new Promise`不一样。

(偷偷告诉你，这道题往下一点有流程图)
过程分析：
- 刚开始整个脚本作为第一次宏任务来执行，我们将它标记为宏`1`，从上至下执行
- 遇到`Promise.resolve().then`这个微任务，将`then`中的内容加入第一次的微任务队列标记为`微1`
- 遇到定时器`timer1`，将它加入下一次宏任务的延迟列表，标记为`宏2`，等待执行(先不管里面是什么内容)
- 执行`宏1`中的同步代码`start`
- 第一次宏任务(`宏1`)执行完毕，检查第一次的微任务队列(`微1`)，发现有一个`promise.then`这个微任务需要执行
- 执行打印出`微1`中同步代码`promise1`，然后发现定时器`timer2`，将它加入`宏2`的后面，标记为`宏3`
- 第一次微任务队列(`微1`)执行完毕，执行第二次宏任务(`宏2`)，首先执行同步代码`timer1`
- 然后遇到了`promise2`这个微任务，将它加入此次循环的微任务队列，标记为`微2`
- 宏任务全部执行完毕，查找微任务队列，发现p`romise.then`这个微任务，执行它。

结果：  
```javascript
1
2
4
"timerStart"
"timerEnd"
"success"
```