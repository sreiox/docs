# browser

## 1. 跨域问题

由于浏览器`同源策略`（浏览器安全功能，它会阻止一个域与另一个域的内容进行交互，能`有效防止XSS、CSRF攻击`）的限制，非同源的请求会被限制。

解决跨域问题的方法：

- 配置nginx反向代理
    跨域解决：location配置中，在响应头上添加允许访问的请求源 Access-Control-Allow-Origin:*
- 使用jsonp方式（script方式）
    利用srcipt标签的src属性来实现，前端声明好一个函数，后端返回执行函数，执行函数参数中携带所需的数据。
    可以使用jquery的ajax快速实现Jsonp。 
    使用jsonp只能解决get请求的跨域，因为script标签中的src请求就是get请求。
- 使用图片
- 设置CORS（跨域资源共享）
    在配置类中，添加一个CORS的过滤器，在响应头上添加允许访问的请求源 addAllowedOrigin("*")
- 利用iframe实现
- WebSocket

## 2. 浏览器的存储有哪些及它们间的区别

- cookie
- session storage
- local storage
- indexedDB:用于客户端存储大量的结构化数据（文件/二进制大型对象（blobs））。该API使用索引实现对数据的高性能搜索。
- cache storage：用于对Cache对象的存储。

## 3. 说说浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起`DNS请求`，得到对应的`IP地址`（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行`TCP三次握手`与服务器建立连接，连接建立后，浏览器会代表用户`发送一个初始的GET请求`，通常是请求一个`HTML文件`。服务器收到对应请求后 ，会根据`相关的响应头和HTML内容进行回复`。

一旦浏览器拿到了数据，就会开始`解析信息`，这个过程中，浏览器会根据`HTML文件去构建DOM树`，当遇到一些`阻塞资源`时（如同步加载的script标签）会去`加载阻塞资源而停止当前DOM树构建`（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的`预加载扫描器会去请求高优先级的资源（如css、js、字体）`，预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理`CSS生成CSSDOM树`，将CSS规则转换为可以理解和使用的`样式映射`，这个过程非常快（通常小于一次DNS查询所需时间）。有了`DOM树和CSSDOM`树，浏览器会将其组合生成一个`Render树`，`计算样式或渲染树会从DOM的根节点开始构建`，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始`布局`，该过程（依旧是从根节点开始）会确定所有节点的`宽高和位置`，最后通过渲染器将其在页面上`绘制`。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

![tupian](./assets/img/16.webp)





