# 手写题

## 手写一个深拷贝

```js
function deepClone(obj){
    if(typeof obj !== 'object' || typeof obj === null) return obj;

    const result = obj instanceof Array? []: {}

    for(let key in obj){

        result[key] = deepClone(obj[key])
        //浅拷贝 resutl[key] = obj[key]
    } 
    return result;
}

const obj = {a: 1, b: {c:3}, d: 5}
const objClone = deepClone(obj)
obj.a = 123
console.log(obj) //{a: 123, b: {…}, d: 5}
console.log(objClone) //{a: 1, b: {…}, d: 5}
```

## 手写防抖和节流函数

### 防抖


#### 停止触发事件n毫秒后执行回调函数

触发事件后函数不会立即执行，而是在停止事件触发后 n 毫秒后执行，如果在 n 毫秒内又触发了事件，则会重新计时

```js
function debounce(fn, delay){
    let timer = null;

    return function(){

        if(timer) clearTimeout(timer)

        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}
```

#### 触发事件后立即执行回调函数，但是触发后n毫秒内不会再执行回调函数，如果 n 毫秒内触发了事件，也会重新计时。

```js
function debounce(fn, delay){
    let timer;

    return function(){

        let isImmediate = !timer

        if(timer) clearTimeout(timer)
        
        timer = setTimeout(() => {
            timer = null
        }, delay)

        if(isImmediate) {
            fn.apply(this, arguments)
            
        }
    }
}
```
举个例子来对比一下两个版本的区别：

```js
document.body.onclick= debounce(function () { console.log('hello') },1000)

```
如上代码中，我们给body添加了一个点击事件监听器。

如果是版本1的防抖函数，当我点击body时，控制台不会立即打印hello,要等 1000ms 后才会打印。在这 1000s 内如果还点击了 body，那么就会重新计时。即最后一次点击 body 过1000ms后控制台才会打印hello

如果是版本2的防抖函数，当我首次点击body时，控制台会立马打印 hello，但是在此之后的 1000ms 内点击 body ，控制台不会有任何反应。在这 1000s 内如果还点击了 body，那么就会重新计时。必须等计时结束后再点击body，控制台才会再次打印 hello。

### 节流

```js
function throttle(fn, delay){
    let timer;
    return function(){
        
    }
}
```

