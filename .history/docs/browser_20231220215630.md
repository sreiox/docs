# browser

## 1. 跨域问题

由于浏览器`同源策略`（浏览器安全功能，它会阻止一个域与另一个域的内容进行交互，能`有效防止XSS、CSRF攻击`）的限制，非同源的请求会被限制。

解决跨域问题的方法：

- 配置nginx反向代理
    跨域解决：location配置中，在响应头上添加允许访问的请求源 Access-Control-Allow-Origin:*
- 使用jsonp方式（script方式）
    利用srcipt标签的src属性来实现，前端声明好一个函数，后端返回执行函数，执行函数参数中携带所需的数据。
    可以使用jquery的ajax快速实现Jsonp。 
    使用jsonp只能解决get请求的跨域，因为script标签中的src请求就是get请求。
- 使用图片
- 设置CORS（跨域资源共享）
    在配置类中，添加一个CORS的过滤器，在响应头上添加允许访问的请求源 addAllowedOrigin("*")
- 利用iframe实现
- WebSocket

## 2. 浏览器的存储有哪些及它们间的区别

- cookie
- session storage
- local storage
- indexedDB:用于客户端存储大量的结构化数据（文件/二进制大型对象（blobs））。该API使用索引实现对数据的高性能搜索。
- cache storage：用于对Cache对象的存储。

## 3. 说说浏览器渲染页面的过程

首先输入一个网址，浏览器会向服务器发起`DNS请求`，得到对应的`IP地址`（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行`TCP三次握手`与服务器建立连接，连接建立后，浏览器会代表用户`发送一个初始的GET请求`，通常是请求一个`HTML文件`。服务器收到对应请求后 ，会根据`相关的响应头和HTML内容进行回复`。

一旦浏览器拿到了数据，就会开始`解析信息`，这个过程中，浏览器会根据`HTML文件去构建DOM树`，当遇到一些`阻塞资源`时（如同步加载的script标签）会去`加载阻塞资源而停止当前DOM树构建`（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的`预加载扫描器会去请求高优先级的资源（如css、js、字体）`，预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理`CSS生成CSSDOM树`，将CSS规则转换为可以理解和使用的`样式映射`，这个过程非常快（通常小于一次DNS查询所需时间）。有了`DOM树和CSSDOM`树，浏览器会将其组合生成一个`Render树`，`计算样式或渲染树会从DOM的根节点开始构建`，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始`布局`，该过程（依旧是从根节点开始）会确定所有节点的`宽高和位置`，最后通过渲染器将其在页面上`绘制`。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

![tupian](./assets/img/16.webp)

## 4. 说下线程和进程

`进程`：一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。
`线程`：进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。
`与进程不同的是`同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

## 5. 说下堆和栈

- 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其
操作方式类似于数据结构中的栈。
- 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回
收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

## 6. http和https的区别

`HTTP（Hypertext Transfer Protocol`）和`HTTPS（Hypertext Transfer Protocol Secure）`是用于在`客户端和服务器之间传输数据的协议`。它们之间的主要区别在于`安全性和数据传输方式`：

- `安全性`：`HTTP是明文`传输协议，数据在传输过程中不加密，因此容易被恶意攻击者截取和篡改。而`HTTPS通过使用SSL`（Secure Sockets Layer）或`TLS`（Transport Layer Security）协议`对数据进行加密和身份验证`，确保数据在传输过程中的安全性。
- `数据传输方式`：`HTTP`使用的默认端口是`80`，而`HTTPS`使用的默认端口是`443`。`HTTP`的数据传输是`明文`的，而`HTTPS`的数据传输是`加密`的
- `证书`：为了使用`HTTPS`，服务器需要获得一个`数字证书`，该证书由权威机构颁发，用于验证服务器的身份和加密通信。而HTTP不需要使用证书。 总结来说，`HTTPS比HTTP更安全，因为它通过加密数据传输来保护用户的隐私和安全。在处理敏感信息（例如登录凭证、支付信息等）时，建议使用HTTPS来确保数据的安全传输。`

## 7. get和post的区别

get和post是HTTP协议中常用的两种请求方法，它们之间的主要区别如下：

1. `数据传输方式`： 
    - GET：通过`URL参数传递数据`，数据会附加在URL的末尾，以键值对的形式出现，例如：`example.com?name=John&age=25 `,GET请求通常`用于获取数据`，对`服务器的数据不会产生影响`。
    - POST: 通过`请求体传递数据`，数据不会附加在URL上，而是作为请求的一部分发送。POST请求通常`用于提交数据`，对`服务器的数据进行修改添加`。
2. `数据传输安全`
    - GET：数据以`明文形式出现在URL`上，因此在传输过程中`不够安全`。`适用于非敏感数据`。
    - POST：数据通过`请求体传输`，不会直接暴露在URL上，相对`更安全`。`适用于敏感数据`。
3. `数据长度限制`
    - `GET`：由于数据附加在URL上，`URL的长度受限制`，不适合传输大量数据。 
    - `POST`：由于数据在请求体中传输，`没有URL长度限制`，适合传输大量数据。
4. `缓存`
    - `GET：请求会被浏览器缓存`，可以通过浏览器的后`退按钮重新加载页面`。
    - `POST：请求不会被浏览器缓存`，重新加载页面时会重新发送请求。
5. `安全性`
    - GET：由于`数据暴露在URL`上，`容易被恶意攻击者截取和篡改`。
    - POST：相对于GET请求，POST请求的数据传输更加安全，因为数据不会直接暴露在URL上。

综上所述，`GET适合用于获取数据，POST适合用于提交数据`，根据具体的需求和数据的安全性要求选择合适的请求方法。

## 8. css加载会造成阻塞吗

CSS加载会造成浏览器的渲染阻塞。这是因为:

1. 浏览器在解析HTML文档时,会遇到link标签加载外部CSS文件,此时浏览器会暂停HTML解析,直到CSS文件加载完成。
2. 浏览器需要构建DOM树和CSSOM,并将两者合并成渲染树,才能开始页面渲染。如果CSS文件没有加载完成,浏览器无法构建渲染树,因此无法渲染页面。
3. CSS的加载和解析是同步的,浏览器需要等待CSS文件完全加载和解析完成后才会继续渲染页面。 

以上三个原因会造成CSS加载对浏览器的渲染产生阻塞效应。

为了避免这种阻塞,我们可以采取以下措施:

- 将CSS代码`内联`在HTML文档中,而不是使用外部CSS文件。这可以避免浏览器暂停HTML解析等待CSS文件加载的阻塞。
- 使用`media`属性为CSS文件指定media类型,使其只在`特定媒体加载`。例如:
```html
<link rel="stylesheet" media="print" href="print.css">
```
- 使用`CSS预加载`技术`preload`,提前加载CSS文件,避免其加载阻塞页面渲染。例如:
```html
<link rel="preload" href="style.css" as="style">
<link rel="stylesheet" href="style.css">
```
- 使用`CSS异步加载库`,如loadCSS,可以异步加载CSS文件,避免其加载造成的阻塞。
- 将CSS代码拆分成多个文件,并采用上述方法加载,可以减少单个CSS文件对渲染的阻塞时间。 

综上,CSS的加载会对浏览器的渲染产生一定的阻塞效应,我们可以通过各种方法来优化,减少这种阻塞。


## 9. 说下tcp和http

`TCP（传输控制协议）`和`HTTP（超文本传输协议）`是计算机网络中的两个重要协议。

`TCP是一种可靠的传输协议`，用于在网络上可靠地传输数据。它提供了面向连接的通信方式，确保数据的可靠性和顺序性。

TCP使用`三次握手`建立连接，然后通过`序列号和确认应答`来保证数据的`可靠传输`。它还具备`流量控制`和`拥塞控制`的机制，以确保网络的稳定性和公平性。

`HTTP是一种应用层协议`，用于在`Web上传输超文本文档`。它是`基于客户端-服务器模型`的协议，客户端发送HTTP请求，服务器返回HTTP响应。`HTTP使用URL（统一资源定位符）来定位资源`，并使用不同的方法（如GET、POST、PUT、DELETE等）来对资源进行操作。它还支持`状态管理`和`会话管理`等功能，使得Web应用能够实现用户认证、数据交互等操作。

TCP和HTTP之间的关系是，`HTTP是建立在TCP协议之上的`。在进行HTTP通信时，首先需要建立TCP连接，然后在该连接上发送HTTP请求和接收HTTP响应。

总结一下，`TCP是一种传输协议`，`用于可靠地传输数据`，而`HTTP是一种应用层协议`，`用于在Web上传输超文本文档`。它们在计算机网络中扮演着不同的角色，但在Web通信中密切配合，确保数据的可靠传输和资源的访问。

## 10. dns缓存

当我们`第一次访问`某个网站时，`DNS在返回对应的IP地址后`，系统会将这个记录`临时存储`下来，并为其`设定一个有效期限（TTL）`，在`有效期限内再次访问`该网站，系统会`直接将该结果返回`，而`无需求助DNS系统进行全球查询`。这个临时储存下来的记录就是`DNS缓存`。如果超过DNS缓存的有效期限再次对该网站，系统会自动再次询问DNS服务器以获得最新的结果。

### DNS缓存有什么作用？

`DNS域名解析采用的是UDP协议通讯`，受外部网络环境的影响较大，尤其是在`有丢包的情况下会产生较高的时延`，严重影响用户上网体验，而DNS缓存机制就是在这种背景下产生的。

DNS缓存可以在`用户发起请求`时，直接`将记录结果返回`，`不需要委托递归服务器进行全球查询`，这样就极大提升了DNS域名解析效率，减小了多次查询所带来的时延问题。此外，由于不必每次都请求权威解析服务器进行查询，所以缓存机制还能大幅节省权威服务器的性能消耗，减轻权威服务器的请求压力。

### DNS缓存的缺点

DNS缓存虽然能够在一定程度上`提升域名解析的速度`，但同样也存在一些弊端，如DNS缓存需要`消耗一定的系统资源`，增加了域名系统的复杂性。此外`TTL值的设置对于平衡DNS解析速度和精度产生了较大影响`。如果`TTL值较短`，能够在`较短时间内刷新最新解析`记录，但会对`解析服务器造成较大压力`；如果`TTL过大`，则可能`导致地址变更`时，用户`无法及时获得最新记录`，从而`导致站点不可达或者访问到错误网站`，影响正常业务开展，并增加DNS被劫持的风险。

## 11. 说下浏览器的垃圾回收

浏览器的`垃圾回收（Garbage Collection）`是指浏览器`自动管理`和`回收JavaScript`代码中`不再使用的内存空间`的过程。由于JavaScript是一种高级动态语言，开发者无需手动分配和释放内存，因此浏览器的垃圾回收机制非常重要。

浏览器的垃圾回收器主要负责以下几个方面：

- `标记清除（Mark and Sweep）`：这是最常见的垃圾回收算法。垃圾回收器会周期性地`遍历`所有的对象，并`标记出活动对象和不活动对象`。然后，它会清除那些没有被标记的不活动对象，释放它们占用的内存空间。
- `引用计数（Reference Counting）`：这是另一种常见的垃圾回收算法。垃圾回收器会为`每个对象维护一个引用计数器`，当对象被引用时计数器加一，当引用失效时计数器减一。当计数器为零时，垃圾回收器会清除该对象。然而，引用计数算法无法处理循环引用的情况，因此现代浏览器很少使用该算法。
- `分代回收（Generational Collection）`：这是一种优化的垃圾回收策略。根据`对象的生命周期将内存分为不同的代`（generation），并为每个代应用不同的回收策略。通常，新创建的对象会被分配到第一代，而经过多次垃圾回收仍然存活的对象则会被提升到下一代。这种策略可以提高垃圾回收的效率。

浏览器的`垃圾回收器通常在空闲时执行垃圾回收操作`，以避免影响页面的性能。然而，垃圾回收的执行时间仍然会对页面的响应性产生一定的影响。因此，开发者应该`尽量避免创建大量临时对象，减少内存占用`，优化代码结构，以提高浏览器的性能和响应速度。

## 12. 什么是内存泄露

在前端开发中，`内存泄露指的是在网页或应用程序中，分配的内存空间没有被正确释放或回收，导致这部分内存无法再被程序使用`，从而造成内存资源的浪费。

在前端中，内存泄露通常发生在使用JavaScript等脚本语言编写的网页或应用程序中。以下是一些常见的导致内存泄露的情况：

- `未正确释放事件监听器`：如果在网页中添加了事件监听器（如点击事件、滚动事件等），但在元素被移除或页面卸载时没有正确移除这些监听器，就会导致内存泄露。
- `引用计数错误`：在JavaScript中，对象的引用计数是用来决定何时释放对象内存的一种机制。如果存在循环引用，即两个或多个对象相互引用，但没有其他地方引用它们，那么这些对象的内存就无法被垃圾回收机制释放，从而导致内存泄露。
- `定时器未清理`：在使用定时器（如 setTimeout 、 setInterval ）时，如果没有正确清理定时器，即使页面或应用程序关闭，定时器仍然会持续运行，导致内存泄露。
- `全局变量未释放`：如果在全局作用域中定义了变量或对象，并且这些变量或对象没有被及时清除或释放，就会导致内存泄露。

内存泄露会导致网页或应用程序`占用过多的内存资源`，从而影响性能和用户体验。为了避免内存泄露，开发者应该注意及时释放不再使用的资源、`正确管理事件监听器、避免循环引用等。`同时，使用浏览器的`开发者工具和内存分析工具`可以帮助检测和解决内存泄露问题。










