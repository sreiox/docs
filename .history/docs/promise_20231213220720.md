# promise

promise如何工作，首先了解`eventloop`执行顺序：
- 一开始整个脚本作为一个宏任务执行
- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
- 当前宏任务完成，检查微任务列表，有则依次执行，知道全部执行完成
- 执行浏览器ui线程得渲染工作
- 检查是否有`web work`任务，有则执行
- 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

**微任务**包括：`MutationObserver`、`Promise.then()`或`catch()`、`Promise为基础开发的其它技术`，比如`fetch API`、`V8`的垃圾回收过程、`Node独有的process.nextTick`。  

**宏任务**包括：`script` 、`setTimeout`、`setInterval` 、`setImmediate` 、`I/O` 、`UI rendering`。  

>注意⚠️：在所有任务开始的时候，由于宏任务中包括了`script`，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如`setTimeout`)将被放到下一轮宏任务中来执行。  

### 1. promise几道基础题

#### 1.1 题目一
```javascript
<script>
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
</script>
```

过程分析：  
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 然后执行同步代码`1`，此时`promise1`没有被`resolve`或者`reject`，因此状态还是`pending`  

结果：  
```javascript
'promise1'
'1' Promise{<pending>}
```
#### 1.2 题目二
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
</script>
```
过程分析：  
- 从上至下，先遇到`new Promise`，执行其中的同步代码`1`
- 再遇到`resolve('success')`， 将`promise`的状态改为了`resolved`并且将值保存下来  
- 继续执行同步代码`2`
- 跳出`promise`，往下执行，碰到`promise.then`这个微任务，将其加入微任务队列
- 执行同步代码`4`
- 本轮宏任务全部执行完毕，检查微任务队列，发现`promise.then`这个微任务且状态为`resolved`，执行它。

结果：  
```javascript
1 2 4 3
```
#### 1.3 题目三
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
</script>
```
过程分析：  
- 和题目二相似，只不过在`promise`中并没有`resolve`或者`reject`
- 因此`promise.then`并不会执行，它只有在被改变了状态之后才会执行。

结果：  
```javascript
1 2 4 
```
#### 1.4 题目四
```javascript
<script>
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);

</script>
```
过程分析：  
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`promise1`
- 碰到`resolve`函数, 将`promise1`的状态改变为`resolved`, 并将结果保存下来
- 碰到`promise1.then`这个微任务，将它放入微任务队列
- `promise2`是一个新的状态为`pending`的`Promise`
- 执行同步代码`1`， 同时打印出`promise1`的状态是`resolved`
- 执行同步代码`2`，同时打印出`promise2`的状态是`pending`
- 宏任务执行完毕，查找微任务队列，发现`promise1.then`这个微任务且状态为`resolved`，执行它。
结果：  
```md
'promise1'
'1' Promise{<resolved>: 'resolve1'}
'2' Promise{<pending>}
'resolve1' 
```
#### 1.5 题目五
```javascript
<script>
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')

</script>
```
这道题里最先执行的是'`start`'吗 🤔️ ？

请仔细看看哦，`fn`函数它是直接返回了一个`new Promise`的，而且`fn`函数的调用是在`start`之前，所以它里面的内容应该会先执行。
结果：  
```md
1
'start'
'success'
```
### 2. Promise结合setTimeout  
   
#### 2.1 题目一
```javascript
<script>
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')

</script>
```
过程分析：  
- 刚开始整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出`start`和`end`。
- `setTimout`作为一个宏任务被放入宏任务队列(下一个)
- `Promise.then`作为一个微任务被放入微任务队列
- 本次宏任务执行完，检查微任务，发现`Promise.then`，执行它
- 接下来进入下一个宏任务，发现`setTimeout`，执行。

结果：  
```javascript
'start'
'end'
'resolve'
'time'
```
#### 2.2 题目二
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);
</script>
```
过程分析：
和题目`1.2`很像，不过在`resolve`的外层加了一层`setTimeout`定时器。
- 从上至下，先遇到`new Promise`，执行该构造函数中的代码`1`
- 然后碰到了定时器，将这个定时器中的函数放到下一个宏任务的延迟队列中等待执行
- 执行同步代码`2`
- 跳出`promise`函数，遇到`promise.then`，但其状态还是为`pending`，这里理解为先不执行
- 执行同步代码`4`
- 一轮循环过后，进入第二次宏任务，发现延迟队列中有`setTimeout`定时器，执行它
- 首先执行`timerStart`，然后遇到了`resolve`，将promise的状态改为`resolved`且保存结果并将之前的`promise.then`推入微任务队列
- 继续执行同步代码`timerEnd`
- 宏任务全部执行完毕，查找微任务队列，发现p`romise.then`这个微任务，执行它。

结果：  
```javascript
1
2
4
"timerStart"
"timerEnd"
"success"
```
#### 2.3 题目三
题目三分了两个题目，因为看着都差不多，不过执行的结果却不一样，大家不妨先猜猜下面两个题目分别执行什么  
①
```javascript
<script>
setTimeout(() => {
  console.log('timer1');
  setTimeout(() => {
    console.log('timer3')
  }, 0)
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')

</script>
```
②
```javascript
setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')

</script>
```
过程分析：
这两个例子，看着好像只是把第一个定时器中的内容换了一下而已。  
一个是为定时器`timer3`，一个是为`Promise.then`  
但是如果是定时器`timer3`的话，它会在`timer2`后执行，而`Promise.then`却是在`timer2`之前执行。  
你可以这样理解，`Promise.then`是微任务，它会被加入到本轮中的微任务列表，而定时器`timer3`是宏任务，它会被加入到下一轮的宏任务中。  
理解完这两个案例，可以来看看下面一道比较难的题目了。

结果： ① 
```javascript
'start'
'timer1'
'timer2'
'timer3'
```
②
```javascript
'start'
'timer1'
'promise'
'timer2'
```
#### 2.4 题目四
```javascript
<script>
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');

</script>
```
这道题稍微的难一些，在`promise`中执行定时器，又在定时器中执行`promise`；

并且要注意的是，这里的`Promise`是直接`resolve`的，而之前的`new Promise`不一样。

(偷偷告诉你，这道题往下一点有流程图)
过程分析：
- 刚开始整个脚本作为第一次宏任务来执行，我们将它标记为宏`1`，从上至下执行
- 遇到`Promise.resolve().then`这个微任务，将`then`中的内容加入第一次的微任务队列标记为`微1`
- 遇到定时器`timer1`，将它加入下一次宏任务的延迟列表，标记为`宏2`，等待执行(先不管里面是什么内容)
- 执行`宏1`中的同步代码`start`
- 第一次宏任务(`宏1`)执行完毕，检查第一次的微任务队列(`微1`)，发现有一个`promise.then`这个微任务需要执行
- 执行打印出`微1`中同步代码`promise1`，然后发现定时器`timer2`，将它加入`宏2`的后面，标记为`宏3`
- 第一次微任务队列(`微1`)执行完毕，执行第二次宏任务(`宏2`)，首先执行同步代码`timer1`
- 然后遇到了`promise2`这个微任务，将它加入此次循环的微任务队列，标记为`微2`
- `宏2`中没有同步代码可执行了，查找本次循环的微任务队列(`微2`)，发现了`promise2`，执行它
- 第二轮执行完毕，执行`宏3`，打印出`timer2`

结果：  
```javascript
'start'
'promise1'
'timer1'
'promise2'
'timer2'
```
#### 2.5 题目五
```javascript
<script>
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)

</script>
```
过程分析：
- 从上至下，先执行第一个`new Promise`中的函数，碰到`setTimeout`将它加入下一个宏任务列表
- 跳出`new Promise`，碰到`promise1.then`这个微任务，但其状态还是为`pending`，这里理解为先不执行
- `promise2`是一个新的状态为`pending`的`Promise`
- 执行同步代码`console.log('promise1')`，且打印出的`promise1`的状态为`pending`
- 执行同步代码`console.log('promise2')`，且打印出的`promise2`的状态为`pending`
- 碰到第二个定时器，将其放入下一个宏任务列表
- 第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务
- 先执行第一个定时器里的内容，将`promise1`的状态改为`resolved`且保存结果并将之前的`promise1.then`推入微任务队列
- 该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是`promise1.then`，它抛出了一个错误，且将`promise2`的状态设置为了`rejected`
- 第一个定时器执行完毕，开始执行第二个定时器中的内容
- 打印出`'promise1'`，且此时`promise1`的状态为`resolved`
- 打印出`'promise2'`，且此时`promise2`的状态为`rejected`

结果：  
```javascript
'promise1' Promise{<pending>}
'promise2' Promise{<pending>}
test5.html:102 Uncaught (in promise) Error: error!!! at test.html:102
'promise1' Promise{<resolved>: "success"}
'promise2' Promise{<rejected>: Error: error!!!}
```

>注意，new promise同步执行，promise.then微队列等待执行

### 3. Promise中的then、catch、finally
1. `Promise`的状态一经改变就不能再改变。(见3.1)
2. `.then`和`.catch`都会返回一个新的`Promise`。(上面的👆1.4证明了)
3. `.catch`不管被连接到哪里，都能捕获上层未捕捉过的错误。(见3.2)
4. 在`Promise`中，返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象，例如`return 2`会被包装为`return Promise.resolve(2)`。
5. `Promise` 的 `.then` 或者 `.catch` 可以被调用多次, 但如果`Promise`内部的状态一经改变，并且有了一个值，那么后续每次调用`.then`或者`.catch`的时候都会直接拿到该值。(见3.5)
6. `.then` 或者 `.catch` 中 `return` 一个 `error` 对象并不会抛出错误，所以不会被后续的 `.catch` 捕获。(见3.6)
7. `.then` 或 `.catch` 返回的值不能是 `promise` 本身，否则会造成死循环。(见3.7)
8. `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。(见3.8)
9. `.then`方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为`catch`是`.then`第二个参数的简便写法。(见3.9)
10. `.finally`方法也是返回一个`Promise`，他在`Promise`结束的时候，无论结果为r`esolved`还是`rejected`，都会执行里面的回调函数。  

#### 3.1 题目一
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  })

</script>
```
过程分析：
构造函数中的 `resolve` 或 `reject` 只有第一次执行有效，多次调用没有任何作用 。验证了第一个结论，`Promise的状态一经改变就不能再改变`。

结果：  
```javascript
"then: success1"
```
#### 3.2 题目二
```javascript
<script>
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then1: ", res);
  }).then(res => {
    console.log("then2: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  }).then(res => {
    console.log("then3: ", res);
  })

</script>
```
过程分析：
验证了第三个结论，`catch`不管被连接到哪里，都能捕获上层未捕捉过的错误。

至于`then3`也会被执行，那是因为`catch()`也会返回一个`Promise`，且由于这个`Promise`没有返回值，所以打印出来的是`undefined`。
结果：  
```javascript
"catch: " "error"
"then3: " undefined
```
#### 3.3 题目三
```javascript
<script>
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });

</script>
```
过程分析：
`Promise`可以链式调用，不过`promise` 每次调用 `.then` 或者 `.catch` 都会返回一个新的 `promise`，从而实现了链式调用, 它并不像一般我们任务的链式调用一样`return this`。  

上面的输出结果之所以依次打印出`1`和`2`，那是因为`resolve(1)`之后走的是第一个`then`方法，并没有走`catch`里，所以第二个`then`中的`res`得到的实际上是第一个`then`的返回值。  

且`return 2`会被包装成`resolve(2)`。  

结果：  
```javascript
1
2
```
#### 3.4 题目四
如果把`3.3`中的`Promise.resolve(1)`改为`Promise.reject(1)`又会怎么样呢？


```javascript
<script>
Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3
  })
  .then(res => {
    console.log(res);
  });

</script>
```
过程分析：
结果打印的当然是 `1` 和 `3`啦，因为`reject(1)`此时走的就是`catch`，且第二个`then`中的`res`得到的就是`catch`中的返回值。  

结果：  
```javascript
1
3
```
#### 3.5 题目五

```javascript
<script>
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('timer')
    resolve('success')
  }, 1000)
})
const start = Date.now();
promise.then(res => {
  console.log(res, Date.now() - start)
})
promise.then(res => {
  console.log(res, Date.now() - start)
})

</script>
```
过程分析：

`Promise` 的 `.then` 或者 `.catch` 可以被调用多次，但这里 `Promise` 构造函数只执行一次。或者说 `promise` 内部状态一经改变，并且有了一个值，那么后续每次调用 `.then` 或者 `.catch` 都会直接拿到该值。

结果：  
```javascript
'timer'
'success' 1001
'success' 1002
```
#### 3.6 题目六

```javascript
<script>
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})

</script>
```
过程分析：

猜猜这里的结果输出的是什么 🤔️ ？  

你可能想到的是进入.catch然后被捕获了错误。  

结果并不是这样的，它走的是.then里面：

结果：  
```javascript
"then: " "Error: error!!!"
```
这也验证了`第4点`和`第6点`，返回任意一个非 `promise` 的值都会被包裹成 `promise` 对象，因此这里的`return new Error('error!!!')`也被包裹成了`return Promise.resolve(new Error('error!!!'))`。  

当然如果你抛出一个错误的话，可以用下面👇两的任意一种:
```javascript
return Promise.reject(new Error('error!!!'));
// or
throw new Error('error!!!')
```
#### 3.7 题目七

```javascript
<script>
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)

</script>
```
过程分析：
.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。

因此结果会报错

结果：  
```javascript
Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```
#### 3.8 题目八

```javascript
<script>
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)

</script>
```
过程分析：
其实你只要记住原则8：`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生`值透传`。

第一个`then`和第二个`then`中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将`resolve(1)` 的值直接传到`最后一个then`里。


结果：  
```javascript
1
```
#### 3.9 题目九
下面来介绍一下.then函数中的两个参数。  

第一个参数是用来处理`Promise`成功的函数，第二个则是处理失败的函数。  

也就是说`Promise.resolve('1')`的值会进入成功的函数，`Promise.reject('2')`的值会进入失败的函数。  

让我们来看看这个例子🌰：
```javascript
<script>
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })

</script>
```

结果：  
```javascript
'error' 'error!!!'
```
它进入的是then()中的第二个参数里面，而如果把第二个参数去掉，就进入了catch()中：
```javascript
Promise.reject('error!!!')
  .then((res) => {
    console.log('success', res)
  }).catch(err => {
    console.log('catch', err)
  })
```
结果：
```javascript
'catch' 'error!!!'
```
但是有一个问题，如果是这个案例呢？
```javascript
Promise.resolve()
  .then(function success (res) {
    throw new Error('error!!!')
  }, function fail1 (err) {
    console.log('fail1', err)
  }).catch(function fail2 (err) {
    console.log('fail2', err)
  })
```
由于`Promise`调用的是`resolve()`，因此`.then()`执行的应该是`success()`函数，可是`success()`函数抛出的是一个错误，它会被`后面的catch()`给捕获到，而不是被`fail1`函数捕获。  

结果：
```javascript
fail2 Error: error!!!
			at success
```
#### 3.10 题目十
接着来看看`.finally()`，这个功能一般不太用在面试中，不过如果碰到了你也应该知道该如何处理。  

其实你只要记住它三个很重要的知识点就可以了：  

1. `.finally()`方法不管`Promise`对象最后的状态如何都会执行
2. `.finally()`方法的回调函数不接受任何的参数，也就是说你在`.finally()`函数中是没法知道`Promise`最终的状态是`resolved`还是rejected的
它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。

来看看这个简单的例子🌰：

作者：LinDaiDai_霖呆呆
链接：https://juejin.cn/post/6844904077537574919
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```javascript
<script>
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)

</script>
```
过程分析：
其实你只要记住原则8：`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生`值透传`。

第一个`then`和第二个`then`中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将`resolve(1)` 的值直接传到`最后一个then`里。


结果：  
```javascript
1
```