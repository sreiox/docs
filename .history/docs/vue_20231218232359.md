# vue

## 1. 虚拟DOM

采用`虚拟DOM`的更新技术在性能这块，理论上是不可能比原生Js操作DOM高的。不过在大部分情况下，开发者很难写出绝对优化的命令式代码。所以虚拟DOM就是用来解决这一问题，让开发者系的代码在性能上得到保障，甚至无限接近命令式代码的性能。

通常情况下，`纯Js层面的操作`远比`DOM操作快`。`虚拟DOM就是用Js来模拟出DOM结构`，`通过diff算法来计算出最小的变更`，通过对应的渲染器，来渲染到页面上。

同时`虚拟DOM`也为跨平台开发提供了极大的便利，开发者写的同一套代码（有些需要针对不同平台做区分），通过不同的渲染规则，就可以生成不同平台的代码。

在`vue`中会通过`渲染器`来将虚拟DOM转换为对应平台的真实DOM。如`renderer(vnode， container)`，该方法会根据`vnode`描述的信息（如tag、props、children）来创建DOM元素，根据规则为对应的元素添加属性和事件，`处理vnode下的children`。

## 2. vue3的变化（改进）

- 响应式方面
    `vue3`的响应式是基于`Proxy`来实现的，利用`代理来拦截对象`的基本操作，配合`Refelect.*`方法来完成响应式的操作。
- 书写方面
    提供了`setup`的方式，配合`组合式API`，可以建立组合逻辑、创建响应式数据、创建通用函数、注册生命周期钩子等
- diff算法方面:
    - 在`vue2`中使用的是`双端diff`算法：是一种`同时比较新旧两组节点的两个端点的算法`（比头、比尾、头尾比、尾头比）。一般情况下，先找出变更后的头部，再对剩下的进行双端diff。
    - 在`vue3`中使用的是`快速diff`算法：它借鉴了文本diff算法的预处理思路，先处理新旧两组节点中相同的前置节点和后置节点。当前置节点和后置节点全部处理完毕后，如果`无法通过简单的挂载新节点或者卸载已经不存在的节点来更新`，则需要根据`节点间的索引关系`，构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。
- 编译上的优化
    - `vue3`新增了`PatchFlags`来标记节点类型（动态节点收集与补丁标志），会在一个`Block`维度下的`vnode`下收集到对应的`dynamicChildren`（动态节点），在执行更新时，忽略`vnode`的`children`，去直接找到`动态节点数组`进行更新，这是一种高效率的`靶向更新`。
    - `vue3`提供了静态提升方式来`优化重复渲染静态节点`的问题，结合静态提升，还对静态节点进行`预字符串化`，减少了虚拟节点的性能开销，降低了内存占用。
    - `vue3`会将`内联事件进行缓存`，每次渲染函数重新执行时会优先取缓存里的事件