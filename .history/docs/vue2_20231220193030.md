# vue2

## 0. 原理解读

### defineProperty/get/set

```js
//Object.defineProperty(obj, 'foo', {configurable: true, writable: true, enumable: true})
function convert(obj){
    Object.keys(obj).forEach(key => {
        let initalValue = obj[key];
        Object.defineProperty(obj, key, {
            get () {
                return initalValue
            }
            set (newValue) {
                initalValue = newValue
            }
        })
    })
}
```

### 依赖追踪（订阅者模式）

```js
window.Dep = Class Dep {
    constructor(){
        this.subscribers = new Set()
    }

    depend(){
        // 依赖收集
        if(activeUpdate){
            this.subscribers.add(activeUpdate)
        }
    }

    notify(){
        // 通知订阅者执行
        this.subscribers.forEach(sub => sub())
    }
}

let activeUpdate

function autorun(update){
    // activeUpdate本质记录正在执行
    function wrappedUpdate{
        activeUpdate = wrappedUpdate
        update()
        activeUpdate = null
    }

    wrappedUpdate()
}

const dep = new Dep()
autorun(() => {
    dep.depend()
})
```

```js
let state = { count: 0 }
// 首先对象通过defineproperty开启监控
obeserve(state)

autorun(() => {
    console.log(state.count)
})

state.count++
```

## 说一下vue2的生命周期？

1. 创建：
    - beforecreate: 实例创建前, 此阶段的data、methods、computed、watch的数据和方法不能被访问
    - created: 实例创建完成后, 此阶段完成数据监听，可以使用数据、更改数据。无法与Dom进行交互，想要的话可以通过nextTick来访问。
2. 挂载
    - beforeMount: 页面渲染前, 此阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。
    - mounted: 页面渲染完成后, 此阶段真实Dom渲染完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。
3. 更新
    - beforeUpdate: 响应式数据更新前, 此阶段更改数据，不会造成页面重新渲染。
    - updated: 响应式数据更新完成后, 避免在此阶段更改数据，因为这可能会导致无限循环的更新。
4. 销毁
    - beforeDestroy: 实例销毁前, 我们可以在这时进行善后收尾工作，比如清除定时器、解除绑定事件
    - destroyed: 实例销毁完成后
5. 缓存
    - activited: `keep-alive`专属，组件被激活时调用
    - deactivited: keep-alive专属，组件被销毁时调用

### 异步请求放在created还是mounted

首先明确的一个前提是：请求是异步的。

在Created生命周期里Data才生成，而请求返回的数据需要挂载在data上，所以Created里是可以初始化请求的，但是 Created 的这时候DOM还没有初始化；

Mounted生命周期里DOM才初始化渲染完成
常规生命周期

作者：风萧何
链接：https://juejin.cn/post/6989496048557228046
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 1. 什么是Vue以及Vue的特点

vue是一套用于构建用户界面的渐进式（自底向上逐层应用）js框架

1. 组件化开发
2. 无需操作DOM
3. 使用虚拟DOM和diff算法复用DOM节点

## 2. SPA及其优缺点

SPA:signal page application，单一页面应用。

一旦页面加载完成，不会因为用户在浏览器上的操作而进行`跳转`、`刷新`，取而代之的是利用`路由机制实现的HTML内容的变换`、UI和用户的交互，`避免`页面的`重新加载`。

数据需要通过ajax请求获取。

优点：

1. 避免不必要的跳转和重复渲染，提高了用户的体验，减轻了服务器的压力。
2. `前后端分离`，使架构更加清晰。

缺点：

1. 初次加载耗时长（可以通过`按需加载`来避免）。
2. 浏览器的前进后退不可以使用，要自己建立堆栈来进行页面切换。
3. SEO难度大。因为就一个页面。

## 2. v-if和v-show的区别

v-if是真正的条件渲染，`不停地的进行销毁和重建`，但若初始条件为假时，就什么也不做。

v-show无论初始渲染条件是否为真，`都进行渲染`，只是使用“display”属性来控制是否在页面上显示

::: tip
Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.
:::


## 3. [class 和 style如何动态绑定](https://vuejs.org/guide/essentials/class-and-style.html)

都可以通过对象和数组来绑定。

## 4. 怎样理解Vue的单项数据流

父级的prop的更新会向下流动到子级的prop里，但是反过来不可以， 若想反过来，只能通过`$emit`派发一个自定义事件，父组件接到后由父组件修改

## 5. 
