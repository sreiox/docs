## 前言

`Vite` 作为 Vue 团队出品的构建工具，其超快的`冷启动`以及`热更新`速度让它迅速🔥起来了。  

由于浏览器开始原生支持 `ES` 模块，`Vite`巧妙的利用生态系统中的新进展解决了 `Webpack` 构建`速度慢`，`HMR(热更新)迟钝`等问题。  

`Vite`作为思维比较前卫且先进的构建工具，我们有必要学一学。前一段时间，阿里等大厂已经开始问 Vite了，综上，我整理了5个常见的Vite面试题，希望能帮助到大家  

## 1. 如何指定 vite 插件 的执行顺序？

可以使用 `enforce` 修饰符来强制插件的位置:

- `pre`：在 `Vite` 核心插件之前调用该插件
- 默认：在 `Vite` 核心插件之后调用该插件
- `post`：在 `Vite` 构建插件之后调用该插件

## 2. vite 插件 常见的 hook 有哪些？

`hook`: 即`钩子`。Vite 会在生命周期的不同阶段中去调用不同的插件以达到不同的目的.

- `config`： 可用于修改 `vite config`，用户可以通过这个 `hook` 修改 `config`；例如 `vite-aliases` 这个插件可以帮助我们自动生成别名。它利用的就是这个钩子。


- `configResolved`： 在解析 `Vite` 配置后调用，用于获取解析完毕的 `config`，在这个 hook 中不建议修改 config。


- `configureServer`： 用于给 `dev server` 添加自定义 `middleware`；例如 `vite-plugin-mock` 插件就是在这个生命周期调用的


- `configurePreviewServer`：与 `configureServer` 相同但是作为预览服务器。`vite preview`插件就是利用这个钩子。


- `transformIndexHtml`：注入变量，用来转换 `HTML` 的内容。`vite-plugin-html` 插件可以帮助我们在html里注入变量，就是利用这个钩子


- `handleHotUpdate`：执行自定义 `HMR` 更新处理

## 3. Vite是否支持 commonjs 写法？

纯业务代码，一般建议采用 `ESM` 写法。如果引入的三方组件或者三方库采用了 `CJS` 写法，`vite` 在预构建的时候就会将 `CJS` 模块转化为 `ESM` 模块。  

如果非要在业务代码中采用 `CJS` 模块，那么我们可以提供一个 `vite` 插件，定义 `load hook`，在 `hook` 内部识别是 `CJS` 模块还是 `ESM` 模块。如果是 `CJS` 模块，利用 `esbuild` 的 `transfrom` 功能，将 `CJS `模块转化为 `ESM` 模块。

## 4. 为什么说 vite 比 webpack 要快

和 `webpack` 对比，为什么 `vite` 的`冷启动、热启动、热更新`都会快？这就要说说二者的区别。

使用 `webpack` 时，从 `yarn start` 命令启动，到最后页面展示，需要经历的过程：

1. 以 `entry` 配置项为起点，做一个`全量`的打包，并生成一个入口文件 `index.html` 文件；
2. 启动一个 `node` 服务；
3. 打开浏览器，去访问入 `index.html`，然后去加载已经打包好的 `js、css` 文件；

在整个工作过程中，最重要的就是第一步中的`全量打包`，中间涉及到构建 `module graph` (涉及到大量度文件操作、文件内容解析、文件内容转换)、`chunk` 构建，这个需要消耗大量的时间。尽管在二次启动、热更新过程中，在构建 `module graph` 中可以充分利用缓存，但随着项目的规模越来越大，整个开发体验也越来越差。

![这是图片](./assets/img/1.webp "Magic Gardens")
>在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。诸如 webpack、Rollup 和 Parcel 等工具应运而生。  
>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。