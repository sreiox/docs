import{_ as e,o,c,R as d}from"./chunks/framework.KWiR4A1k.js";const i="/public/assets/1.MDhpxKyp.webp",t="/public/assets/2.Jau-oU9K.webp",k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vite.md","filePath":"vite.md"}'),l={name:"vite.md"},a=d('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><code>Vite</code> 作为 Vue 团队出品的构建工具，其超快的<code>冷启动</code>以及<code>热更新</code>速度让它迅速🔥起来了。</p><p>由于浏览器开始原生支持 <code>ES</code> 模块，<code>Vite</code>巧妙的利用生态系统中的新进展解决了 <code>Webpack</code> 构建<code>速度慢</code>，<code>HMR(热更新)迟钝</code>等问题。</p><p><code>Vite</code>作为思维比较前卫且先进的构建工具，我们有必要学一学。前一段时间，阿里等大厂已经开始问 Vite了，综上，我整理了5个常见的Vite面试题，希望能帮助到大家</p><h2 id="_1-如何指定-vite-插件-的执行顺序" tabindex="-1">1. 如何指定 vite 插件 的执行顺序？ <a class="header-anchor" href="#_1-如何指定-vite-插件-的执行顺序" aria-label="Permalink to &quot;1. 如何指定 vite 插件 的执行顺序？&quot;">​</a></h2><p>可以使用 <code>enforce</code> 修饰符来强制插件的位置:</p><ul><li><code>pre</code>：在 <code>Vite</code> 核心插件之前调用该插件</li><li>默认：在 <code>Vite</code> 核心插件之后调用该插件</li><li><code>post</code>：在 <code>Vite</code> 构建插件之后调用该插件</li></ul><h2 id="_2-vite-插件-常见的-hook-有哪些" tabindex="-1">2. vite 插件 常见的 hook 有哪些？ <a class="header-anchor" href="#_2-vite-插件-常见的-hook-有哪些" aria-label="Permalink to &quot;2. vite 插件 常见的 hook 有哪些？&quot;">​</a></h2><p><code>hook</code>: 即<code>钩子</code>。Vite 会在生命周期的不同阶段中去调用不同的插件以达到不同的目的.</p><ul><li><p><code>config</code>： 可用于修改 <code>vite config</code>，用户可以通过这个 <code>hook</code> 修改 <code>config</code>；例如 <code>vite-aliases</code> 这个插件可以帮助我们自动生成别名。它利用的就是这个钩子。</p></li><li><p><code>configResolved</code>： 在解析 <code>Vite</code> 配置后调用，用于获取解析完毕的 <code>config</code>，在这个 hook 中不建议修改 config。</p></li><li><p><code>configureServer</code>： 用于给 <code>dev server</code> 添加自定义 <code>middleware</code>；例如 <code>vite-plugin-mock</code> 插件就是在这个生命周期调用的</p></li><li><p><code>configurePreviewServer</code>：与 <code>configureServer</code> 相同但是作为预览服务器。<code>vite preview</code>插件就是利用这个钩子。</p></li><li><p><code>transformIndexHtml</code>：注入变量，用来转换 <code>HTML</code> 的内容。<code>vite-plugin-html</code> 插件可以帮助我们在html里注入变量，就是利用这个钩子</p></li><li><p><code>handleHotUpdate</code>：执行自定义 <code>HMR</code> 更新处理</p></li></ul><h2 id="_3-vite是否支持-commonjs-写法" tabindex="-1">3. Vite是否支持 commonjs 写法？ <a class="header-anchor" href="#_3-vite是否支持-commonjs-写法" aria-label="Permalink to &quot;3. Vite是否支持 commonjs 写法？&quot;">​</a></h2><p>纯业务代码，一般建议采用 <code>ESM</code> 写法。如果引入的三方组件或者三方库采用了 <code>CJS</code> 写法，<code>vite</code> 在预构建的时候就会将 <code>CJS</code> 模块转化为 <code>ESM</code> 模块。</p><p>如果非要在业务代码中采用 <code>CJS</code> 模块，那么我们可以提供一个 <code>vite</code> 插件，定义 <code>load hook</code>，在 <code>hook</code> 内部识别是 <code>CJS</code> 模块还是 <code>ESM</code> 模块。如果是 <code>CJS</code> 模块，利用 <code>esbuild</code> 的 <code>transfrom</code> 功能，将 <code>CJS </code>模块转化为 <code>ESM</code> 模块。</p><h2 id="_4-为什么说-vite-比-webpack-要快" tabindex="-1">4. 为什么说 vite 比 webpack 要快 <a class="header-anchor" href="#_4-为什么说-vite-比-webpack-要快" aria-label="Permalink to &quot;4. 为什么说 vite 比 webpack 要快&quot;">​</a></h2><p>简单记：<code>vite</code>在开环境时基于<code>ESBuild</code>打包，相比webpack的编译方式，大大提高了项目的启动和热更新速度。</p><p>和 <code>webpack</code> 对比，为什么 <code>vite</code> 的<code>冷启动、热启动、热更新</code>都会快？这就要说说二者的区别。</p><p>使用 <code>webpack</code> 时，从 <code>yarn start</code> 命令启动，到最后页面展示，需要经历的过程：</p><ol><li>以 <code>entry</code> 配置项为起点，做一个<code>全量</code>的打包，并生成一个入口文件 <code>index.html</code> 文件；</li><li>启动一个 <code>node</code> 服务；</li><li>打开浏览器，去访问入 <code>index.html</code>，然后去加载已经打包好的 <code>js、css</code> 文件；</li></ol><p>在整个工作过程中，最重要的就是第一步中的<code>全量打包</code>，中间涉及到构建 <code>module graph</code> (涉及到大量度文件操作、文件内容解析、文件内容转换)、<code>chunk</code> 构建，这个需要消耗大量的时间。尽管在二次启动、热更新过程中，在构建 <code>module graph</code> 中可以充分利用缓存，但随着项目的规模越来越大，整个开发体验也越来越差。</p><p><img src="'+i+'" alt="这是图片" title="Magic Gardens"></p><blockquote><p>在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。诸如 webpack、Rollup 和 Parcel 等工具应运而生。</p></blockquote><blockquote><p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。</p></blockquote><p>使用 <code>vite</code> 时， 从 <code>vite</code> 命令启动，到最后的页面展示，需要经历的过程：</p><ol><li>使用 <code>esbuild</code> 预构建依赖，提前将项目的第三方依赖格式化为 <code>ESM</code> 模块；</li><li>启动一个 <code>node</code> 服务；</li><li>打开浏览器，去访问 <code>index.html</code>；</li><li>基于浏览器已经支持原生的 <code>ESM </code>模块, 逐步去加载入口文件以及入口文件的依赖模块。浏览器发起请求以后，<code>dev server</code> 端会通过 <code>middlewares</code> 对请求做拦截，然后对源文件做 <code>resolve</code>、<code>load</code>、<code>transform</code>、<code>parse</code> 操作，然后再将转换以后的内容发送给浏览器。</li></ol><p>在<code>第四步</code>中，<code>vite</code> 需要逐步去加载入口文件以及入口文件的依赖模块，但在实际应用中，这个过程中涉及的模块的数量级并不大，需要的时间也较短。而且在分析模块的依赖关系时， <code>vite</code> 采用的是 <code>esbuild</code>，<code>esbuild</code> 使用 <code>Go</code> 编写，比以 <code>JavaScript</code> 编写的打包器预构建依赖快 <code>10-100</code> 倍（<code>webpack</code> 就是采用 <code>js</code> ）</p><p><img src="'+t+'" alt="这是图片" title="Magic Gardens"></p><p>综上，开发模式下 vite 比 webpack 快的原因：</p><ol><li><code>vite</code> 不需要做全量的打包，这是比 <code>webpack</code> 要快的最主要的原因；</li><li><code>vite</code> 在解析模块依赖关系时，利用了 <code>esbuild</code>，更快（<code>esbuild</code> 使用 <code>Go</code> 编写，并且比以 <code>JavaScript</code> 编写的打包器预构建依赖快 <code>10-100</code> 倍）；</li><li>按需加载；模块之间的依赖关系的解析由浏览器实现。<code>Vite</code> 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。</li><li>充分利用缓存；<code>Vite</code> 利用 <code>HTTP</code> 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 <code>304 Not Modified</code> 进行协商缓存，而依赖模块请求则会通过 C<code>ache-Control: max-age=31536000,immutable</code> 进行强缓存，因此一旦被缓存它们将不需要再次请求。</li></ol><h2 id="_5-vite-对比-webpack-优缺点在哪" tabindex="-1">5. vite 对比 webpack ，优缺点在哪 <a class="header-anchor" href="#_5-vite-对比-webpack-优缺点在哪" aria-label="Permalink to &quot;5. vite 对比 webpack ，优缺点在哪&quot;">​</a></h2><p><strong>优点：</strong></p><ol><li><code>更快的冷启动</code>：<code>Vite</code> 借助了浏览器对 <code>ESM</code> 规范的支持，采取了与 <code>Webpack</code> 完全不同的 <code>unbundle</code> 机制</li><li><code>更快的热更新</code>：<code>Vite</code> 采用 <code>unbundle</code> 机制，所以 <code>dev server</code> 在监听到文件发生变化以后，只需要通过 <code>ws</code> 连接通知浏览器去重新加载变化的文件，剩下的工作就交给浏览器去做了。</li></ol><p><strong>缺点：</strong></p><ol><li><code>开发环境下首屏加载变慢</code>：由于 <code>unbundle</code> 机制，<code>Vite</code> 首屏期间需要额外做其它工作。不过首屏性能差只发生在 <code>dev server</code> 启动以后第一次加载页面时发生。之后再 <code>reload</code> 页面时，首屏性能会好很多。原因是 <code>dev server</code> 会将之前已经完成转换的内容缓存起来</li><li><code>开发环境下懒加载变慢</code>：跟首屏加载变慢的原因一样。<code>Vite</code> 在懒加载方面的性能也比 <code>Webpack</code> 差。由于 <code>unbundle</code> 机制，动态加载的文件，需要做 <code>resolve</code>、<code>load</code>、<code>transform</code>、<code>parse</code> 操作，并且还有大量的 <code>http</code> 请求，导致懒加载性能也受到影响。</li><li><code>webpack</code>支持的更广。由于 <code>Vite </code>基于<code>ES Module</code>，所以代码中不可以使用<code>CommonJs</code>；<code>webpack</code>更多的关注兼容性, 而<code>Vite</code> 关注浏览器端的开发体验。<code>Vite</code>目前生态还不如 <code>Webpack</code>。</li></ol><blockquote><p>当需要打包到生产环境时，<code>Vite</code>使用传统的<code>rollup</code>进行打包，所以，<code>vite</code>的优势是体现在开发阶段，缺点也只是在开发阶段存在。</p></blockquote>',34),p=[a];function r(s,n,v,u,h,b){return o(),c("div",null,p)}const _=e(l,[["render",r]]);export{k as __pageData,_ as default};
